// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `AGMWorldModel.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef ____AGMWorldModel_h__
#define ____AGMWorldModel_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace RoboCompAGMWorldModel
{

typedef ::std::map< ::std::string, ::std::string> StringDictionary;

enum BehaviorResultType
{
    InitialWorld,
    BehaviorBasedModification,
    BehaviorBasedNumericUpdate,
    StatusFailTimeout,
    StatusFailOther,
    StatusActive,
    StatusIdle
};

struct Node
{
    ::RoboCompAGMWorldModel::StringDictionary attributes;
    ::Ice::Int nodeIdentifier;
    ::std::string nodeType;

    bool operator==(const Node& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(attributes != __rhs.attributes)
        {
            return false;
        }
        if(nodeIdentifier != __rhs.nodeIdentifier)
        {
            return false;
        }
        if(nodeType != __rhs.nodeType)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Node& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(attributes < __rhs.attributes)
        {
            return true;
        }
        else if(__rhs.attributes < attributes)
        {
            return false;
        }
        if(nodeIdentifier < __rhs.nodeIdentifier)
        {
            return true;
        }
        else if(__rhs.nodeIdentifier < nodeIdentifier)
        {
            return false;
        }
        if(nodeType < __rhs.nodeType)
        {
            return true;
        }
        else if(__rhs.nodeType < nodeType)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Node& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Node& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Node& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Node& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::RoboCompAGMWorldModel::Node> NodeSequence;

struct Edge
{
    ::RoboCompAGMWorldModel::StringDictionary attributes;
    ::Ice::Int a;
    ::Ice::Int b;
    ::std::string edgeType;

    bool operator==(const Edge& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(attributes != __rhs.attributes)
        {
            return false;
        }
        if(a != __rhs.a)
        {
            return false;
        }
        if(b != __rhs.b)
        {
            return false;
        }
        if(edgeType != __rhs.edgeType)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Edge& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(attributes < __rhs.attributes)
        {
            return true;
        }
        else if(__rhs.attributes < attributes)
        {
            return false;
        }
        if(a < __rhs.a)
        {
            return true;
        }
        else if(__rhs.a < a)
        {
            return false;
        }
        if(b < __rhs.b)
        {
            return true;
        }
        else if(__rhs.b < b)
        {
            return false;
        }
        if(edgeType < __rhs.edgeType)
        {
            return true;
        }
        else if(__rhs.edgeType < edgeType)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Edge& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Edge& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Edge& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Edge& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::RoboCompAGMWorldModel::Edge> EdgeSequence;

struct World
{
    ::RoboCompAGMWorldModel::NodeSequence nodes;
    ::RoboCompAGMWorldModel::EdgeSequence edges;

    bool operator==(const World& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(nodes != __rhs.nodes)
        {
            return false;
        }
        if(edges != __rhs.edges)
        {
            return false;
        }
        return true;
    }

    bool operator<(const World& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(nodes < __rhs.nodes)
        {
            return true;
        }
        else if(__rhs.nodes < nodes)
        {
            return false;
        }
        if(edges < __rhs.edges)
        {
            return true;
        }
        else if(__rhs.edges < edges)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const World& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const World& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const World& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const World& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct Event
{
    ::RoboCompAGMWorldModel::BehaviorResultType why;
    ::RoboCompAGMWorldModel::World backModel;
    ::RoboCompAGMWorldModel::World newModel;
    ::std::string sender;

    bool operator==(const Event& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(why != __rhs.why)
        {
            return false;
        }
        if(backModel != __rhs.backModel)
        {
            return false;
        }
        if(newModel != __rhs.newModel)
        {
            return false;
        }
        if(sender != __rhs.sender)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Event& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(why < __rhs.why)
        {
            return true;
        }
        else if(__rhs.why < why)
        {
            return false;
        }
        if(backModel < __rhs.backModel)
        {
            return true;
        }
        else if(__rhs.backModel < backModel)
        {
            return false;
        }
        if(newModel < __rhs.newModel)
        {
            return true;
        }
        else if(__rhs.newModel < newModel)
        {
            return false;
        }
        if(sender < __rhs.sender)
        {
            return true;
        }
        else if(__rhs.sender < sender)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Event& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Event& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Event& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Event& __rhs) const
    {
        return !operator<(__rhs);
    }
};

}

namespace Ice
{
template<>
struct StreamableTraits< ::RoboCompAGMWorldModel::BehaviorResultType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::RoboCompAGMWorldModel::Node>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::RoboCompAGMWorldModel::Node, S>
{
    static void write(S* __os, const ::RoboCompAGMWorldModel::Node& v)
    {
        __os->write(v.attributes);
        __os->write(v.nodeIdentifier);
        __os->write(v.nodeType);
    }
};

template<class S>
struct StreamReader< ::RoboCompAGMWorldModel::Node, S>
{
    static void read(S* __is, ::RoboCompAGMWorldModel::Node& v)
    {
        __is->read(v.attributes);
        __is->read(v.nodeIdentifier);
        __is->read(v.nodeType);
    }
};

template<>
struct StreamableTraits< ::RoboCompAGMWorldModel::Edge>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::RoboCompAGMWorldModel::Edge, S>
{
    static void write(S* __os, const ::RoboCompAGMWorldModel::Edge& v)
    {
        __os->write(v.attributes);
        __os->write(v.a);
        __os->write(v.b);
        __os->write(v.edgeType);
    }
};

template<class S>
struct StreamReader< ::RoboCompAGMWorldModel::Edge, S>
{
    static void read(S* __is, ::RoboCompAGMWorldModel::Edge& v)
    {
        __is->read(v.attributes);
        __is->read(v.a);
        __is->read(v.b);
        __is->read(v.edgeType);
    }
};

template<>
struct StreamableTraits< ::RoboCompAGMWorldModel::World>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::RoboCompAGMWorldModel::World, S>
{
    static void write(S* __os, const ::RoboCompAGMWorldModel::World& v)
    {
        __os->write(v.nodes);
        __os->write(v.edges);
    }
};

template<class S>
struct StreamReader< ::RoboCompAGMWorldModel::World, S>
{
    static void read(S* __is, ::RoboCompAGMWorldModel::World& v)
    {
        __is->read(v.nodes);
        __is->read(v.edges);
    }
};

template<>
struct StreamableTraits< ::RoboCompAGMWorldModel::Event>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::RoboCompAGMWorldModel::Event, S>
{
    static void write(S* __os, const ::RoboCompAGMWorldModel::Event& v)
    {
        __os->write(v.why);
        __os->write(v.backModel);
        __os->write(v.newModel);
        __os->write(v.sender);
    }
};

template<class S>
struct StreamReader< ::RoboCompAGMWorldModel::Event, S>
{
    static void read(S* __is, ::RoboCompAGMWorldModel::Event& v)
    {
        __is->read(v.why);
        __is->read(v.backModel);
        __is->read(v.newModel);
        __is->read(v.sender);
    }
};

}

#endif
